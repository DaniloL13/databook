![Pandas](../img/cubo.jpg)
# Numpy

### Computo Numérico en Python

El lenguaje Fortran es conocido como el primer lenguaje de programación de alto nivel y sigue siendo hasta el día de hoy muy importante para el computo científico y de alto rendimiento. Fortran se considera la referencia cuando hablamos de bibliotecas numéricas para realizar operaciones con vectores y matrices. Bibliotecas como [LAPACK](http://www.netlib.org/lapack/) (Linear Algebra Package) o [BLAS](http://www.netlib.org/blas/) tienen más de 25 años de desarrollo. Muchas herramientas e incluso lenguajes de programación se han diseñado para realizar operaciones numéricas sin tener que programar en Fortran o C, por ejemplo MATLAB, Maple o Mathematica. El problema con estas plataformas propietarias es que crean una dependencia del proveedor. Existen opciones de código libre que incluso son compatibles con los productos anteriores como GNU Octave y SageMath el cual al igual que  Mathematica incluye el concepto de Notebooks. En el caso de lenguajes dos exponentes importante son Julia y R. En el caso de Python contamos con [NumPy](http://www.numpy.org/) como componente básico para el computo científico. Entre otras cosas nos brinda:

* Una estructura para arreglos de N-dimensiones.
* Herramientas para integrar código en Fortran y C//C++
* Soporte para álgebra lineal, transformadas de Fourier y números aleatorios.
* Integración con sistemas de bases de datos.
* Operaciones entre arreglos de distintas dimensiones (Broadcasting).

El código de NumPy tiene una [licencia de código abierto BSD](http://www.numpy.org/license.html#license).

NumPy se utiliza en conjunto con otras bibliotecas y herramientas como **matplotlib**, **SciPy**, **Pandas**, **Jupiter**, **IPython**, **scikit-learn**, **theano**, **orange** entre otras para complementar con una plataforma bastante decente. Como son muchos componentes existen distribuciones que integran todo y más, por ejemplo [sage] (https://www.sagemath.org/),[Canopy](https://www.enthought.com/product/canopy/)y [Anaconda Distribution](https://www.anaconda.com/distribution/).

### ndarray

Mientras que en Python tenemos colecciones de objetos tipo secuencia como las listas, estas no siempre tienen una estructura adecuada que nos permita definir operaciones generales para que se hagan sobre ellas. Por ejemplo la lista de listas:

```python
>>> lista_objetos = [[1,2,3],[2,2],['Hola', 11],[2]]
```
Tiene dos problemas: las listas son de distintos tamaños y tiene objetos de distintos tipos. Por ejemplo, no podemos sumar todos los números en la primera posición o en la tercera. Em el primer caso no podemos sumar a la cadena 'Hola' y en el segundo hay una lista que no tiene un elemento en la tercera posición. La estructura básica de NumPy es un arreglo homogéneo multidimensional. De una manera muy básica una lista con ciertas reglas. Primero, es un arreglo homogéneo, es decir todos los elementos son del mismo tipo. Como queremos hacer operaciones casi siempre son de tipo numérico. Segundo, las listas tienen el tamaño correspondiente. Vamos a corregir nuestra lista:

```python
>>> lista_nums = [[1, 2, 3],[2, 2, 4],[2, 3, 11], [2, 1, 4]]
```
Esta lista de objetos es entonces homogénea y digamos cuadrada ya que todas las listas interiores tienen el mismo número de elementos. Podríamos decir que es un arreglo homogéneo de dos dimensiones:

```python
>>> import numpy as np
>>> arreglo = np.array(lista_nums)
>>> arreglo
array([[ 1,  2,  3],
       [ 2,  2,  4],
       [ 2,  3, 11],
       [ 2,  1,  4]])
```
Podemos decir que una dimensión de este arreglo son los renglones y otra dimensión son las columnas. Y su tipo de dato son los enteros:

```python
>>> arreglo.dtype
dtype('int64')
```
¿Que pasaría si queremos hacer un arreglo con la lista de objetos?. Vamos a intentarlo:

```python
>>> arreglo_objs = np.array(lista_objetos)
>>> arreglo_objs
array([[1, 2, 3], [2, 2], ['Hola', 11], [2]], dtype=object)
```
Como vemos no se crea un arreglo de dos dimensiones, se crea un arreglo de una sola dimensión con objetos de un mismo tipo: **object**. Esto por supuesto no es muy útil. Pero es un ejemplo de un arreglo de dimensión uno, heterogéneo pero no de una manera muy útil ya que no podemos hacer muchas operaciones matemáticas con objetos tipo **object**.

Vamos a crear un arreglo dimensión-1 de enteros:

```python
>>> arreglo_enteros = np.array([1 , 2, 45])
>>> arreglo_enteros
array([ 1,  2, 45])
```
Podemos ahora desplegar el atributo dimensión de los arreglos:
```python
>>> arreglo.ndim
2
>>> arreglo_enteros.ndim
1
```
El número de dimensiones se le conoce como el **Rank** del arreglo. Pero también es importante la *forma* (**shape**) del arreglo:

```python
>>> arreglo.shape
(4, 3)
```
El primer valor de la tupla nos dice el número de renglón y el segundo el número de columna. Para acordarnos de este orden podemos imaginar que los arreglos o matrices son como los cines. Para encontrar el asiento debemos primero ubicar la fila y después el número de asiento. Veamos el caso del arreglo de una dimensión:

```python
>>> arreglo_enteros.shape
(3,)
```
En este caso podemos ver que se trata de un cine con un solo asiento por fila. El tamaño es el número de elementos, que como vemos es el equivalente del producto de los elementos de la tupla *shape*.

```python
>>> arreglo.size # 4*3
12
```
Podemos también especificar el tipo de dato al crear el arreglo. Por ejemplo:
```python
>>> arreglo_complejos = np.array( [ [3 , 2], [3, 4] ], dtype=complex )
>>> arreglo_complejos
array([[ 3.+0.j,  2.+0.j],
       [ 3.+0.j,  4.+0.j]])
```

En ocasiones queremos crear arreglos con datos iniciales, por ejemplo ceros, unos o valores arbitrarios:
```python
 >>> np.zeros( (3,4) )
array([[ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.]])
>>> np.ones( (2,3,4))  
array([[[ 1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.]],

       [[ 1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.]]])
>>> np.empty( (6,))  
array([ -2.68156159e+154,  -2.68156159e+154,   2.23182566e-314,
        -2.68156159e+154,   6.94181405e-310,   6.15378780e-313])
```

### Selección y cortes en arreglos multidimensionales
Vamos a considerar la siguiente lista de calificaciones donde cada alumno tiene tres calificaciones que van de 0 a 100: 

| id |  nombre       | tarea | examen | proyecto |
|----|---------------|------:|-------:|---------:|
| 1  | Juan Pérez    |  86.2 | 90.0   | 95.0     |
| 2  | Ana Rivas     | 100.0 | 95.0   | 95.0     |
| 3  | María Sánchez |  76.5 | 100.0  | 85.0     |
| 4  | Luis Duarte   |  89.0 | 90.0   | 95.0     |

Vamos a capturar las calificaciones en un arreglo de NumPy:

```python
>>> lista_nums = [[86.2, 90.0, 95.0],[100.0, 95.0, 95.0], 
                 [76.5, 100.0, 85.0], [89.0, 90.0, 95.0]]
>>> cal = np.array(lista_nums)
>>> cal
array([[  86.2,   90. ,   95. ],
       [ 100. ,   95. ,   95. ],
       [  76.5,  100. ,   85. ],
       [  89. ,   90. ,   95. ]])               
```

Los arreglos al igual que otros objetos tipo secuencia tienen indices que inician en cero. El arreglo *cal* tiene dos indices ya que tiene dos dimensiones o ejes (*axes*). Para leer una posición en este caso enviamos una tupla con los dos indices, (*renglón*, *columna*):

``` python
>>> cal[1,0]
  100.0
>>> cal[1,0]
  100.0    
```
Veamos otros ejemplos:
``` python
>>> cal[:,0] # Todas las calificaciones de la tarea
  array([  86.2,  100. ,   76.5,   89. ])

>>> cal[:,0:2] # Tareas y exámenes 
array([[  86.2,   90. ],
       [ 100. ,   95. ],
       [  76.5,  100. ],
       [  89. ,   90. ]])

>>> cal[1:3,:] # Calificaciones de Ana y María
array([[ 100. ,   95. ,   95. ],
       [  76.5,  100. ,   85. ]])
```

Cuando enviamos una tupla con menos indices de que tiene el arreglo, se considera que de los otros ejes queremos todos los elementos:

``` python
>>> cal[0] # Equivalente a cal[0,:]
    array([ 86.2,  90. ,  95. ])
```

Otra manera de indicar lo mismo es utilizando tres puntos (...).

``` python
>>> cal[0, ...] 
    array([ 86.2,  90. ,  95. ])
    
>>> cal[...]
    array([[  86.2,   90. ,   95. ],
           [ 100. ,   95. ,   95. ],
           [  76.5,  100. ,   85. ],
           [  89. ,   90. ,   95. ]])
           
>>> cal[...,2] # Tercera columna 
   array([ 95.,  95.,  85.,  95.]
```
### Operaciones Básicas
Cuando utilizamos operaciones aritméticas sobre arreglos, la operación se realiza para cada elemento y se regresa uno nuevo con el resultado. Vamos a suponer que debido al buen desempeño de todos los alumnos se subirá un punto a todas las calificaciones:

``` python
>>> cal + 1
array([[  87.2,   91. ,   96. ],
       [ 101. ,   96. ,   96. ],
       [  77.5,  101. ,   86. ],
       [  90. ,   91. ,   96. ]]
```
También lo podríamos hacer solo para el primer alumno:

``` python
>>> cal[0] + 1
array([ 87.2,  91. ,  96. ])
```

Las operaciones también se pueden hacer entre arreglos. Por ejemplo, vamos a suponer que podríamos tener una lista con los puntos extra que han obtenido los alumnos:

``` python
>>> puntos = [[0, 1, 0],[1, 0, 0], [0, 0, 0], [1, 2, 4]]
>>> extras = np.array(puntos)    
>>> extras
array([[0, 1, 0],
       [1, 0, 0],
       [0, 0, 0],
       [1, 2, 4]])

>>> cal
array([[  86.2,   90. ,   95. ],
       [ 100. ,   95. ,   95. ],
       [  76.5,  100. ,   85. ],
       [  89. ,   90. ,   95. ]])

>>> cal + extras 
array([[  86.2,   91. ,   95. ],
       [ 101. ,   95. ,   95. ],
       [  76.5,  100. ,   85. ],
       [  90. ,   92. ,   99. ]])
```
En este caso tenemos una calificación errónea ya que no se puede tener 101 de calificación.

Vamos ahora a suponer que deseamos ponderar cada una de las calificaciones, por ejemplo:
 
| tarea | examen | proyecto |
|------:|-------:|---------:|
|  .30  | 30.0   | 40.0     |

NumPy permite realizar operaciones entre arreglos con distinta forma mediante un mecanismo que llaman *Broadcast*. En este caso se hace una busqueda de la operación que tenga sentido. Por ejemplo:

```python
>>> pesos = np.array([.30, .30, .40])
>>> cal * pesos
array([[ 25.86,  27.  ,  38.  ],
       [ 30.  ,  28.5 ,  38.  ],
       [ 22.95,  30.  ,  34.  ],
       [ 26.7 ,  27.  ,  38.  ]])
```
Implícitamente se completa la matriz de pesos para que tenga la misma forma que **cal** y después se hace la multiplicación posición por posición.

Para saber la calificación final de cada alumno se pueden realizar funciones a todos los elementos de un eje. Por ejemplo:

```python
>>> cal_ponderada = cal * pesos
>>> cal_ponderada.sum(axis=1)
array([ 90.86,  96.5 ,  86.95,  91.7 ])  
```
En este caso se suma para cada alumno sus calificaciones ponderadas, dando como resultado la calificación final. 

  

### Iteración