![Pandas](../img/cubo.jpg)
# Numpy

### Computo Numérico en Python

El lenguaje Fortran con sus más de 50 años sigue siendo muy importante para en las áreas de computo científico y de alto rendimiento. Fortran se considera la *referencia* cuando se habla de bibliotecas para cómputo numérico. Bibliotecas como [LAPACK](http://www.netlib.org/lapack/) (Linear Algebra Package) o [BLAS](http://www.netlib.org/blas/) que sirven para  realizar (entre otras cosas) operaciones con vectores y matrices, tienen más de 25 años de desarrollo. Fuera del computo científico el lenguaje Fortran no es tan popular lo que ha provocado el desarrollado herramientas e incluso lenguajes de programación para realizar operaciones numéricas utilizando sus bibliotecas. Herramientas de código cerrado y propietario incluyen a MATLAB, Maple y Mathematica. El problema con estas plataformas es que crean una dependencia del proveedor y un alto costo a los usuarios. Existen opciones de código libre que incluso son compatibles con los productos anteriores como GNU Octave y SageMath. En el caso de lenguajes de programación libres, dos exponentes importantes son [Julia](https://julialang.org/) para el cómputo numérico y [R](https://www.r-project.org/) para el computo estadístico. En el caso de Python contamos con la biblioteca [NumPy](http://www.numpy.org/) como componente básico para el computo científico numérico. Numpy entre otras cosas nos brinda:

* Una estructura para arreglos de N-dimensiones.
* Herramientas para integrar código en Fortran y C//C++
* Soporte para álgebra lineal, transformadas de Fourier y números aleatorios.
* Integración con sistemas de bases de datos.
* Operaciones entre arreglos de distintas dimensiones (Broadcasting).

El código de NumPy tiene una [licencia de código abierto BSD](http://www.numpy.org/license.html#license).

NumPy se utiliza en conjunto con otras bibliotecas y herramientas como **matplotlib**, **SciPy**, **Pandas**, **Jupiter**, **IPython**, **scikit-learn**, **theano**, **orange** para complementar con una plataforma de análisis de datos bastante decente. Al ser muchos los componentes necesarios para contar con una plataforma, se han desarrollado distribuciones que integran todo esto y más, por ejemplo [sage](https://www.sagemath.org/),[Canopy](https://www.enthought.com/product/canopy/) y [Anaconda Distribution](https://www.anaconda.com/distribution/).

Esta sección tipo taller tiene como objetivo que conozcas y apliques los arreglos multidimensionales que ofrece la biblioteca NumPy. Estos conocimientos los utilizaremos en las secciones posteriores.  

### NumPy: array

Mientras que en Python tenemos colecciones de objetos tipo secuencia como las listas, éstas no tienen una estructura adecuada que nos permita realizar operaciones generales sobre ellas. Como ejemplo vemos la siguiente lista de listas:

```python
>>> lista_objetos = [[1,2,3],[2,2],['Hola', 11],[2]]
```
Esta lista no nos permite realizar cierto tipo de operaciones en ella ya que tiene dos problemas: las listas son de distintos tamaños y tienen objetos de distintos tipos. Por ejemplo, no podemos sumar todos los números en la primera posición o en la tercera. En el primer caso no podemos sumar a la cadena 'Hola' y en el segundo hay dos listas que no tienen un elemento en la tercera posición.

La estructura básica de NumPy es un arreglo homogéneo multidimensional. Dicho de otra manera, un arreglo es una lista que sigue ciertas reglas. Primero, es un arreglo homogéneo, es decir todos los elementos son del mismo tipo, casi siempre de tipo numérico. Segundo, todas las listas contenidas tienen el mismo tamaño. Vamos a crear una lista que siga estas reglas:

```python
>>> lista_nums = [[1, 2, 3],[2, 2, 4],[2, 3, 11], [2, 1, 4]]
```

Esta lista es homogénea, ya que tiene puros enteros. Digamos que es cuadrada ya que todas las listas interiores tienen el mismo número de elementos. Podríamos decir que es un arreglo homogéneo de dos dimensiones, vamos a crear un arreglo de NumPy a partir de nuestra lista:

```python
>>> import numpy as np
>>> arreglo = np.array(lista_nums)
>>> arreglo
array([[ 1,  2,  3],
       [ 2,  2,  4],
       [ 2,  3, 11],
       [ 2,  1,  4]])
```

Una dimensión de este arreglo son los renglones y otra dimensión son las columnas. ¿Y su tipo de dato?:

```python
>>> arreglo.dtype
dtype('int64')
```
¿Que pasaría si queremos hacer un arreglo con la anterior lista de objetos?. Vamos a intentarlo:

```python
>>> arreglo_objs = np.array(lista_objetos)
>>> arreglo_objs
array([[1, 2, 3], [2, 2], ['Hola', 11], [2]], dtype=object)
```
Como vemos no se crea un arreglo de dos dimensiones, se crea un arreglo de una sola dimensión con objetos de un mismo tipo: **object**. Esto por supuesto no es muy útil. Nos damos cuenta que *arreglo_objs* es un arreglo de dimensión uno, homogéneo pero no de una manera muy útil ya que no podemos hacer muchas operaciones matemáticas con objetos tipo **object**.

Mejor vamos a crear un arreglo *dimensión-1* que contenga solamente enteros:

```python
>>> arreglo_enteros = np.array([1 , 2, 45])
>>> arreglo_enteros
array([ 1,  2, 45])
```
Podemos ahora desplegar el atributo dimensión de los arreglos:
```python
>>> arreglo.ndim
2
>>> arreglo_enteros.ndim
1
```
El número de dimensiones se le conoce en Numpy como el **Rank** (rango) del arreglo. Un atributo importante es la *forma* (**shape**) del arreglo:

```python
>>> arreglo.shape
(4, 3)
```
El primer valor de la tupla nos dice el número de renglones y el segundo el número de columnas. Para acordarnos de este orden podemos imaginar que los arreglos o matrices son como los cines. Para encontrar nuestro asiento primero debemos ubicar la fila y después el número de asiento. Veamos el caso del arreglo de una dimensión:

```python
>>> arreglo_enteros.shape
(3,)
```
En este caso podemos ver que se trata de un cine con un solo asiento por fila. El tamaño es el número de elementos, que como vemos es el equivalente del producto de los elementos de la tupla *shape*.

```python
>>> arreglo.size # 4*3
12
```
Podemos también especificar el tipo de dato al crear el arreglo. Por ejemplo:
```python
>>> arreglo_complejos = np.array( [ [3 , 2], [3, 4] ], dtype=complex )
>>> arreglo_complejos
array([[ 3.+0.j,  2.+0.j],
       [ 3.+0.j,  4.+0.j]])
```

En ocasiones queremos crear arreglos con datos iniciales, por ejemplo ceros, unos o valores arbitrarios:
```python
 >>> np.zeros( (3,4) )
array([[ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.]])
>>> np.ones( (2,3,4))  
array([[[ 1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.]],

       [[ 1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.],
        [ 1.,  1.,  1.,  1.]]])
>>> np.empty( (6,))  
array([ -2.68156159e+154,  -2.68156159e+154,   2.23182566e-314,
        -2.68156159e+154,   6.94181405e-310,   6.15378780e-313])
```

### Selección y cortes en arreglos multidimensionales
Vamos a considerar la siguiente lista de calificaciones donde cada alumno tiene tres calificaciones que van de 0 a 100:

| id |  nombre       | tarea | examen | proyecto |
|----|---------------|------:|-------:|---------:|
| 1  | Juan Pérez    |  86.2 | 90.0   | 95.0     |
| 2  | Ana Rivas     | 100.0 | 95.0   | 95.0     |
| 3  | María Sánchez |  76.5 | 100.0  | 85.0     |
| 4  | Luis Duarte   |  89.0 | 90.0   | 95.0     |

Vamos a capturar las calificaciones en un arreglo de NumPy:

```python
>>> lista_nums = [[86.2, 90.0, 95.0],[100.0, 95.0, 95.0],
                 [76.5, 100.0, 85.0], [89.0, 90.0, 95.0]]
>>> cal = np.array(lista_nums)
>>> cal
array([[  86.2,   90. ,   95. ],
       [ 100. ,   95. ,   95. ],
       [  76.5,  100. ,   85. ],
       [  89. ,   90. ,   95. ]])               
```

Los arreglos al igual que otros objetos tipo secuencia tienen indices que inician en cero. El arreglo *cal* tiene dos indices ya que tiene dos dimensiones o ejes (*axes*). Para leer una posición en este caso enviamos una tupla con los dos indices, (*renglón*, *columna*):

``` python
>>> cal[1,0]
  100.0
>>> cal[1,0]
  100.0    
```
Veamos otros ejemplos:
``` python
>>> cal[:,0] # Todas las calificaciones de la tarea
  array([  86.2,  100. ,   76.5,   89. ])

>>> cal[:,0:2] # Tareas y exámenes
array([[  86.2,   90. ],
       [ 100. ,   95. ],
       [  76.5,  100. ],
       [  89. ,   90. ]])

>>> cal[1:3,:] # Calificaciones de Ana y María
array([[ 100. ,   95. ,   95. ],
       [  76.5,  100. ,   85. ]])
```

Cuando enviamos una tupla con menos indices de que tiene el arreglo, se considera que de los otros ejes queremos todos los elementos:

``` python
>>> cal[0] # Equivalente a cal[0,:]
    array([ 86.2,  90. ,  95. ])
```

Otra manera de indicar lo mismo es utilizando tres puntos (...).

``` python
>>> cal[0, ...]
    array([ 86.2,  90. ,  95. ])

>>> cal[...]
    array([[  86.2,   90. ,   95. ],
           [ 100. ,   95. ,   95. ],
           [  76.5,  100. ,   85. ],
           [  89. ,   90. ,   95. ]])

>>> cal[...,2] # Tercera columna
   array([ 95.,  95.,  85.,  95.]
```
### Operaciones Básicas
Cuando utilizamos operaciones aritméticas sobre arreglos, la operación se realiza para cada elemento y se regresa uno nuevo con el resultado. Vamos a suponer que debido al buen desempeño de todos los alumnos se subirá un punto a todas las calificaciones:

``` python
>>> cal + 1
array([[  87.2,   91. ,   96. ],
       [ 101. ,   96. ,   96. ],
       [  77.5,  101. ,   86. ],
       [  90. ,   91. ,   96. ]]
```
También lo podríamos hacer solo para el primer alumno:

``` python
>>> cal[0] + 1
array([ 87.2,  91. ,  96. ])
```

Las operaciones también se pueden hacer entre arreglos. Por ejemplo, vamos a suponer que podríamos tener una lista con los puntos extra que han obtenido los alumnos:

``` python
>>> puntos = [[0, 1, 0],[1, 0, 0], [0, 0, 0], [1, 2, 4]]
>>> extras = np.array(puntos)    
>>> extras
array([[0, 1, 0],
       [1, 0, 0],
       [0, 0, 0],
       [1, 2, 4]])

>>> cal
array([[  86.2,   90. ,   95. ],
       [ 100. ,   95. ,   95. ],
       [  76.5,  100. ,   85. ],
       [  89. ,   90. ,   95. ]])

>>> cal + extras
array([[  86.2,   91. ,   95. ],
       [ 101. ,   95. ,   95. ],
       [  76.5,  100. ,   85. ],
       [  90. ,   92. ,   99. ]])
```
En este caso tenemos una calificación errónea ya que no se puede tener 101 de calificación.

Vamos ahora a suponer que deseamos ponderar cada una de las calificaciones, por ejemplo:

| tarea | examen | proyecto |
|------:|-------:|---------:|
|  .30  | .30    | .40      |

NumPy permite realizar operaciones entre arreglos con distinta forma mediante un mecanismo que llaman *Broadcast*. En este caso se hace una búsqueda de la operación que tenga sentido. Por ejemplo:

```python
>>> pesos = np.array([.30, .30, .40])
>>> cal * pesos
array([[ 25.86,  27.  ,  38.  ],
       [ 30.  ,  28.5 ,  38.  ],
       [ 22.95,  30.  ,  34.  ],
       [ 26.7 ,  27.  ,  38.  ]])
```
Implícitamente se completa la matriz de pesos para que tenga la misma forma que **cal** y después se hace la multiplicación posición por posición.

Para saber la calificación final de cada alumno se pueden realizar funciones a todos los elementos de un eje. Por ejemplo:

```python
>>> cal_ponderada = cal * pesos
>>> cal_ponderada.sum(axis=1)
array([ 90.86,  96.5 ,  86.95,  91.7 ])  
```
En este caso se suma para cada alumno sus calificaciones ponderadas, dando como resultado la calificación final.

Para finalizar esta sección vamos a resolver un problema. ¿Como podríamos crear la una matriz de pesos que tenga la misma forma que *cal*?. Digamos:
```python
>>> pesos
array([[ 0.3,  0.3,  0.4],
       [ 0.3,  0.3,  0.4],
       [ 0.3,  0.3,  0.4],
       [ 0.3,  0.3,  0.4]])
```
Para resolver el problema debemos aprovechar las propiedades de los arreglos. Primero vamos a generar un arreglo con la forma de *cal* pero que contenga solo unos:

```python
>>> unos = np.ones((4,3))  
>>> unos
array([[ 1.,  1.,  1.],
       [ 1.,  1.,  1.],
       [ 1.,  1.,  1.],
       [ 1.,  1.,  1.]])
```
Después simplemente multiplicamos este arreglo por el arreglo *pesos*:

```python
>>> pesos = np.array([.30, .30, .40])
>>> unos * pesos
array([[ 0.3,  0.3,  0.4],
       [ 0.3,  0.3,  0.4],
       [ 0.3,  0.3,  0.4],
       [ 0.3,  0.3,  0.4]])
```
Para lograr el mismo objetivo, ¿Podríamos utilizar un arreglo con ceros *np.zeros((4,3))*?

Es importante recordar que estas operaciones no pueden realizarse en las listas convencionales de Python, por ejemplo:

```python
>>> lista = [2,3,4]
>>> lista * 5
[2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4]

>>> np.array([2,3,4]) * 5
array([10, 15, 20])
```

### Iteración
En ocasiones necesitamos recorrer el arreglo haciendo alguna operación sobre los datos. ¡Cuidado! debemos tratar de no utilizar un ciclo *for* para realizar la iteración. 
